const { InstanceBase, Regex, runEntrypoint, InstanceStatus } = require('@companion-module/base')
const UpgradeScripts = require('./upgrades')
const UpdateActions = require('./actions')
const UpdateFeedbacks = require('./feedbacks')
const UpdateVariableDefinitions = require('./variables')
const PerOps = require('./perops' )
const fs = require( "fs" );

class ModuleInstance extends InstanceBase {
	constructor(internal) {
		super(internal)
	}


	m_root_directory = "";
	m_list = {};
	m_ticks = 0;
	m_flash_hcycle_ticks = 10;
	m_enable_logging = false;

	// Need to create array of class instances or dictionaries with the
	// following to store them against the name of the button 
	// Maybe use a dictionary with class instances to access by name easily

//	m_lamp_on = false;
//	m_ld_lamp_on = false;
//	m_is_flashing = false;
//	m_flash_change_tick = 0;
	//var perops;

	async init(config) {
		this.config = config
		this.m_lamp_on = false;
		this.m_tick = 0;
		this.m_root_directory = "/home/companion/python/";

		this.updateStatus(InstanceStatus.Ok)

		this.updateActions() // export actions
		this.updateFeedbacks() // export feedbacks
		this.updateVariableDefinitions() // export variable definitions

		this.setupList( this.m_root_directory + "config/buttons_list.json" );

		// DBM Set a timeer to generate test flashes
		// The problem here seems to be passing the correct value for "this" to the 
		// target function. It seems we just end up with it being a pointer to the SetTimeout()
		// when what we want it the instances of the module instance.
		var perops = setInterval( () => { this.periodicOperations(this);}, 100 );

		// Start watching for feedback files
		this.startFileWatcher();
	}
	// When module gets deleted
	async destroy() {
		this.log('debug', 'destroy')
	}

	async configUpdated(config) {
		this.config = config
	}

	// Return config fields for web config
	getConfigFields() {
		return [
			{
				type: 'textinput',
				id: 'host',
				label: 'Target IP',
				width: 8,
				regex: Regex.IP,
			},
			{
				type: 'textinput',
				id: 'port',
				label: 'Target Port',
				width: 4,
				regex: Regex.PORT,
			},
		]
	}

	updateActions() {
		UpdateActions(this)
	}

	updateFeedbacks() {
		UpdateFeedbacks(this)
	}

	updateVariableDefinitions() {
		UpdateVariableDefinitions(this)
	}

	periodicOperations( self )
	{
		// console.log( 'Tick in main.js' );
		PerOps( self );

	}

	setupList( filename )
	{

		var template = { "m_lamp_on": false, "m_ld_lamp_on": false, "m_is_flashing": false, "m_flash_change_tick": 0 };

		console.log( "Template json ", template );

		// Change to use readFileSync() to read list of buttons from file
		// generated by the python app from the button table.
		// Then parse the text read to get the list of keys to be used here.

		const data = fs.readFileSync( filename, { "encoding": "utf-8", "flag": "r"});

		// var keys = [ "HOLD", "TAKE", "MCUE", "SSWAP" ];

		var keys = JSON.parse( data );
		console.log( "keys ", keys );

		// Need to make sure we don't end up with references to the same object instance here.
		keys.forEach((entry) => this.m_list[entry] = JSON.parse(JSON.stringify(template)));

		//console.log( "List ", this.m_list );
	}

	startFileWatcher()
	{
		console.log( "Starting feedback file watcher" );
		var directory = this.m_root_directory + "feedback/";
		var filename = "data.json";
		var path_name = directory; // + filename;
		fs.watch( path_name, (event, filename) =>
		{

			if ( this.m_enable_logging == true ) console.log( "File changed ", event, filename );

			// console.log( "Reading file : ", filename );
			//fs.readFile( path_name, (err, text) =>
			fs.readFile( path_name + filename, (err, text) =>
			{
				try
				{
					if ( err )
					{
						console.log( "Feed back file content : Read error");
						console.log( err );
						return;
					}
					var commands = JSON.parse( text );
					// console.log( "Feed back file content (json) ", commands );

					// Now process the commands 

					if ( commands == null ) return;

					let index = 0;
					for( index in commands )
					{

						var entry = commands[ index ];
						var key = entry[ "button" ];
						// console.log( "List >>>>> ", this.m_list, "Key >> ", key, entry );

						if ( this.m_list[ key ] == null ) 
						{
							console.log( "Unexpected Button Name : ", key );
							continue;
						}

						switch( entry[ "state" ] )
						{
							case "on":
								if ( this.m_enable_logging == true ) console.log( "Key On for : ", key );
								this.m_list[ key ][ "m_lamp_on" ] = true;
								this.m_list[ key ][ "m_is_flashing" ] = false;
								break;

							case "off":
								if ( this.m_enable_logging == true ) console.log( "Key Off for : ", key );
								this.m_list[ key ][ "m_lamp_on" ] = false;
								this.m_list[ key ][ "m_is_flashing" ] = false;
								break;
	
							case "flash":
								if ( this.m_enable_logging == true ) console.log( "Key Flash for : ", key, this.m_list[ key ]);
								this.m_list[ key ][ "m_lamp_on" ] = false;
								if ( this.m_list[ key ][ "m_is_flashing" ] != true )
								{
									this.m_list[ key ][ "m_is_flashing" ] = true;
									this.m_list[ key ][ "m_flash_change_tick" ] = this.m_ticks;
								}
								break;

							default:
								console.log( "Unknown state for : ", key );
								break;
						}
					}
					this.checkFeedbacks( 'ChannelState' );
					this.checkFeedbacks( 'ChannelComms' );
				}
				catch( error )
				{
					console.log( "Error from read feedback : ", error );
				}
			});
		});
	}
}

runEntrypoint(ModuleInstance, UpgradeScripts)
